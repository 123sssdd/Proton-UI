# 流式渲染原理

流式渲染是 Aether UI 的核心特性之一，专为 AI 对话场景设计，提供流畅的实时文本显示体验。

## 什么是流式渲染？

流式渲染是指将内容逐步、增量地渲染到页面上，而不是等待所有内容就绪后一次性渲染。在 AI 对话场景中，这种技术可以：

- 提供实时反馈，提升用户体验
- 减少等待时间，让用户感知更快
- 支持长文本的渐进式显示
- 模拟真实的打字效果

## 核心架构

```mermaid
graph LR
    A[源内容] --> B[StreamingRenderer]
    B --> C[批处理缓冲区]
    C --> D[RAF 调度器]
    D --> E[渲染输出]
    E --> F[React 组件]
```

### 三层架构

1. **StreamingRenderer**：核心渲染引擎
2. **useStreamingText**：React Hook 封装
3. **StreamingText**：React 组件

## StreamingRenderer 核心类

### 设计思想

StreamingRenderer 是流式渲染的核心，采用批处理 + RAF 节流的策略，在性能和流畅度之间取得平衡。

### 核心算法

#### 1. 批处理缓冲区

```typescript
class StreamingRenderer {
  private buffer: string[] = [];
  private batchSize: number;

  append(content: string): void {
    this.buffer.push(content);

    // 当缓冲区达到批处理大小时，调度渲染
    if (this.buffer.length >= this.batchSize) {
      this.scheduleRender();
    }
  }
}
```

**工作原理：**

- 维护一个字符串缓冲区
- 累积内容直到达到 `batchSize`
- 批量输出，减少渲染次数

**优势：**

- 减少 DOM 操作次数
- 降低 CPU 占用
- 提升整体性能

#### 2. RAF 节流机制

```typescript
class StreamingRenderer {
  private rafId: number | null = null;
  private lastRenderTime: number = 0;
  private maxFPS: number;

  private scheduleRender(): void {
    if (this.rafId !== null) return;

    this.rafId = requestAnimationFrame((timestamp) => {
      this.render(timestamp);
    });
  }

  private render(timestamp: number): void {
    const interval = 1000 / this.maxFPS;

    if (timestamp - this.lastRenderTime < interval) {
      // 未达到帧间隔，重新调度
      this.rafId = null;
      this.scheduleRender();
      return;
    }

    // 执行渲染
    this.flush();
    this.lastRenderTime = timestamp;
    this.rafId = null;
  }
}
```

**工作原理：**

- 使用 `requestAnimationFrame` 调度渲染
- 根据 `maxFPS` 计算帧间隔
- 控制渲染频率，避免过度渲染

**优势：**

- 与浏览器刷新率同步
- 避免阻塞主线程
- 平滑的视觉效果

#### 3. 性能监控

```typescript
class StreamingRenderer {
  private metrics = {
    renderCount: 0,
    totalChars: 0,
    startTime: 0,
  };

  getMetrics() {
    const duration = Date.now() - this.metrics.startTime;
    const avgFPS = (this.metrics.renderCount / duration) * 1000;

    return {
      renderCount: this.metrics.renderCount,
      totalChars: this.metrics.totalChars,
      avgFPS,
      duration,
    };
  }
}
```

**监控指标：**

- 渲染次数
- 总字符数
- 平均帧率
- 渲染时长

## 虚拟补全算法

### 问题背景

在流式渲染 Markdown 内容时，可能会出现不完整的标签，导致渲染错误：

```
输入: "这是一段 **粗体"
问题: 缺少闭合的 **，导致后续内容都变成粗体
```

### 算法原理

虚拟补全算法通过以下步骤解决这个问题：

#### 1. 检测不完整标签

```typescript
const incompleteTagPatterns = [
  /`$/, // 单个反引号
  /``$/, // 两个反引号
  /\*$/, // 单个星号
  /_$/, // 单个下划线
  /~$/, // 单个波浪号
  /\[$/, // 单个左方括号
  /!\[$/, // 图片标记开始
];
```

#### 2. 移除不完整标签

```typescript
let view = content;
for (const pattern of incompleteTagPatterns) {
  if (pattern.test(view)) {
    view = view.replace(pattern, "");
  }
}
```

#### 3. 统计标签数量

````typescript
const codeBlockCount = (view.match(/```/g) || []).length;
const inlineCodeCount = (view.match(/(?<!`)`(?!`)/g) || []).length;
const boldCount = (view.match(/\*\*/g) || []).length;
const italicCount = (view.match(/(?<!\*)\*(?!\*)/g) || []).length;
````

#### 4. 补全闭合标签

````typescript
if (codeBlockCount % 2 === 1) view += "\n```";
if (inlineCodeCount % 2 === 1) view += "`";
if (boldCount % 2 === 1) view += "**";
if (italicCount % 2 === 1) view += "*";
````

### 效果对比

**不启用虚拟补全：**

```
输入: "这是 **粗体"
渲染: "这是 **粗体" （后续内容都变粗体）
```

**启用虚拟补全：**

```
输入: "这是 **粗体"
处理: "这是 **粗体**"
渲染: "这是 粗体" （正常显示）
```

## 性能优化策略

### 1. 批处理大小选择

| 场景                 | batchSize | 说明               |
| -------------------- | --------- | ------------------ |
| 快速流式（打字效果） | 5-10      | 逐字显示，流畅度高 |
| 中速流式（AI 对话）  | 10-20     | 平衡性能和流畅度   |
| 慢速流式（长文本）   | 20-50     | 性能优先           |

### 2. 帧率控制

| 场景     | maxFPS | 说明             |
| -------- | ------ | ---------------- |
| 高端设备 | 60     | 最流畅的体验     |
| 中端设备 | 30     | 平衡性能和流畅度 |
| 低端设备 | 15-20  | 性能优先         |

### 3. 内存优化

```typescript
// 使用增量更新，避免重复渲染
useEffect(() => {
  const newContent = sourceContent.slice(lastLengthRef.current);
  if (newContent) {
    renderer.append(newContent);
    lastLengthRef.current = sourceContent.length;
  }
}, [sourceContent]);
```

### 4. 清理资源

```typescript
useEffect(() => {
  return () => {
    renderer.destroy(); // 清理 RAF 和事件监听
  };
}, []);
```

## 使用场景

### 1. AI 对话

```tsx
<Message
  role="assistant"
  content={streamingContent}
  streaming
  renderContent={(text) => (
    <StreamingText
      content={text}
      batchSize={15}
      maxFPS={60}
      enableVirtualCompletion
    />
  )}
/>
```

### 2. 代码生成

```tsx
<StreamingText
  content={generatedCode}
  batchSize={20}
  maxFPS={30}
  enableVirtualCompletion
  onComplete={() => {
    console.log("代码生成完成");
  }}
/>
```

### 3. 长文本显示

```tsx
<StreamingText content={longArticle} batchSize={50} maxFPS={30} />
```

## 性能基准测试

### 测试场景

- 内容长度：10,000 字符
- 测试设备：MacBook Pro M1
- 浏览器：Chrome 120

### 测试结果

| 配置                    | 渲染次数 | 平均帧率 | CPU 占用 |
| ----------------------- | -------- | -------- | -------- |
| batchSize=5, maxFPS=60  | 2000     | 58 FPS   | 15%      |
| batchSize=10, maxFPS=60 | 1000     | 59 FPS   | 10%      |
| batchSize=20, maxFPS=60 | 500      | 60 FPS   | 8%       |
| batchSize=10, maxFPS=30 | 1000     | 30 FPS   | 6%       |

### 结论

- 增大 `batchSize` 可以显著减少渲染次数和 CPU 占用
- 降低 `maxFPS` 可以进一步降低 CPU 占用
- 推荐配置：`batchSize=15, maxFPS=60`

## 与其他方案对比

### 方案 1：直接更新 DOM

```tsx
// 每次都直接更新
setText(newContent);
```

**问题：**

- 渲染次数 = 字符数
- 大量 DOM 操作
- 性能差

### 方案 2：setTimeout 节流

```tsx
// 使用 setTimeout 节流
setTimeout(() => setText(newContent), 16);
```

**问题：**

- 不与浏览器刷新率同步
- 可能造成卡顿
- 精度不够

### 方案 3：Aether UI 方案

```tsx
// 批处理 + RAF 节流
<StreamingText content={content} batchSize={15} maxFPS={60} />
```

**优势：**

- 批处理减少渲染次数
- RAF 与浏览器同步
- 帧率可控
- 性能最优

## 最佳实践

### 1. 选择合适的参数

```tsx
// AI 对话场景
<StreamingText
  content={content}
  batchSize={15}
  maxFPS={60}
  enableVirtualCompletion
/>

// 代码生成场景
<StreamingText
  content={code}
  batchSize={20}
  maxFPS={30}
  enableVirtualCompletion
/>

// 长文本场景
<StreamingText
  content={article}
  batchSize={50}
  maxFPS={30}
/>
```

### 2. 监控性能

```tsx
const renderer = new StreamingRenderer({
  onRender: (content) => {
    console.log("渲染:", content);
  },
});

// 获取性能指标
const metrics = renderer.getMetrics();
console.log("性能指标:", metrics);
```

### 3. 处理完成事件

```tsx
<StreamingText
  content={content}
  onComplete={() => {
    // 渲染完成后的操作
    console.log("渲染完成");
    // 可以触发其他操作，如启用输入框
  }}
/>
```

### 4. 错误处理

```tsx
try {
  renderer.append(newContent);
} catch (error) {
  console.error("渲染错误:", error);
  // 降级处理
  setText(newContent);
}
```

## 进阶话题

### 自定义渲染器

```typescript
class CustomRenderer extends StreamingRenderer {
  protected onRender(content: string): void {
    // 自定义渲染逻辑
    super.onRender(content);
    // 添加额外的处理
  }
}
```

### 多流合并

```typescript
const renderer1 = new StreamingRenderer();
const renderer2 = new StreamingRenderer();

// 合并多个流
const mergedContent = content1 + content2;
```

### 暂停和恢复

```typescript
// 暂停渲染
renderer.pause();

// 恢复渲染
renderer.resume();
```

## 总结

Aether UI 的流式渲染引擎通过以下技术实现高性能：

1. **批处理缓冲区**：减少渲染次数
2. **RAF 节流**：与浏览器同步，避免阻塞
3. **帧率控制**：平衡性能和流畅度
4. **虚拟补全**：处理不完整的 Markdown 标签
5. **性能监控**：实时追踪性能指标

这些技术使得 Aether UI 能够在 AI 对话场景中提供流畅、高效的用户体验。

## 参考资料

- [requestAnimationFrame MDN](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)
- [React 性能优化](https://react.dev/learn/render-and-commit)
- [Markdown 规范](https://commonmark.org/)
